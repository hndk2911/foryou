<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>For you <3</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
  <link rel="stylesheet" href="css/style.css">
</head>

<body>
  <header></header>
  <nav>
    <div>
      <div class="row">
        <div class="column">
          <img src="img/4.jpg" alt="" style="width: 100%;">
          <img src="img/1.jpg" alt="" style="width: 100%;">
          <img src="img/5.jpg" alt="" style="width: 100%;">

        </div>
        <div class="column">
          <img src="img/3.jpg" alt="" style="width: 100%; padding-bottom: 42px;">
          <img src="img/2.jpg" alt="" style="width: 100%;">
        </div>
      </div>
    </div>
    <div class="letter-image" id="tat" onclick="openLoiNhan()">
      <div class="animated-mail">
        <div class="back-fold"></div>
        <div class="letter">
          <div class="letter-border"></div>
          <div class="letter-title"></div>
          <div class="letter-context"></div>
          <div style="text-align: center;font-size: large; color: #9f37c8;font-weight: bolder;">
            Những lời chân thành
          </div>
          <div class="letter-stamp">
            <div class="letter-stamp-inner"></div>
          </div>
        </div>
        <div class="top-fold"></div>
        <div class="body"></div>
        <div class="left-fold"></div>
      </div>
      <div class="shadow"></div>
    </div>
    <div id="test" style="display: none;">
      <div id="awan" style="width: 500px;left: 34%; top: 31%;">
        <div id="page1" style="text-align: center; font-size: 16px;">
          T suy nghĩ rất lâu rồi nên hôm nay t quyết định nói ra hết những lời này mặc dù t biết cơ hội thành công là
          rất thấp. Nhưng t hy vọng m có thể cho t một cơ hội có thể vượt qua ranh giới bạn bè với m. Trước đây t có
          những hành động, lời nói vượt quá ranh giới khi m đang trong 1 mối quan hệ khác là t sai, nhưng những gì t nói
          là thật, tình cảm đó là thật. T viết những dòng này để bày tỏ hết nỗi lòng t thôi. Có thể m chỉ xem t là bạn,
          nhưng đối với t thì lại khác bởi vì cảm xúc mà đâu ai có thể điều khiển được. Nếu tình yêu giống như 1 câu hỏi
          trắc nghiệm thà khoanh lụi còn hơn để trống, thì m có thể cho t 1 cơ hội được không.
          <img src="https://cdn-icons-png.flaticon.com/16/318/318275.png" onclick="nextPgae()">
        </div>
        <div>

        </div>
        <div id="page2" style="display: none;text-align: center; font-size: 16px;">
          T cũng không biết bản thân t bị làm sao nữa. T không hiểu tại sao t lại cố chấp như vậy nữa. T từng thử cố
          gắng không để ý tới m, không quan tâm tới m nhưng mà kết quả cuối cùng t vẫn làm không được. Có thể t quan tâm
          tới quá nhiều người, đối xử tốt với quá nhiều người tạo cảm giác không an toàn. Có thể t không biết rất nhiều
          thứ, nhưng t biết rằng t có thể dành tất cả cho duy nhất một mình m. Dù thế giới này có người không vì 1 bông hoa mà từ bỏ cả vườn hoa thì t sẽ là người vì một bông hoa mà mặc kệ tất cả. Những lời t viết ra thì có hơi lủng củng
          nhưng tất cả đều xuất phát từ con tim. Có lẽ sau lần này t sẽ không làm phiền m nữa. T chỉ xin được 1 lần ích
          kỷ nếu như t thất bại thì mong t với m sẽ trở lại mối quan hệ bạn bè như trước kia.
        </div>
      </div>
    </div>

    
    <div class="box" style="left: 26%;">

      <canvas id="pinkboard"></canvas>
      <canvas id="pinkboard1" style="left: 131%;"></canvas>

    </div>

  </nav>
  <footer></footer>

  <!-- js của trái tim -->
  <script>
    
  function openLoiNhan(){
    document.getElementById("test").style.display = 'block';
    document.getElementById("tat").style.display = 'none';
  }
    function nextPgae(){
    document.getElementById("page1").style.display = 'none';
    document.getElementById("page2").style.display = 'block';
  }
   /* Settings
  
   */

    var settings = {

      particles: {

        length: 1000, // maximum amount of particles

        duration: 2.6, // particle duration in sec

        velocity: 50, // particle velocity in pixels/sec

        effect: -1.3, // play with this for a nice effect

        size: 13, // particle size in pixels

      },

    };

    /*
    
     * RequestAnimationFrame polyfill by Erik Möller
    
     */

    (function () { var b = 0; var c = ["ms", "moz", "webkit", "o"]; for (var a = 0; a < c.length && !window.requestAnimationFrame; ++a) { window.requestAnimationFrame = window[c[a] + "RequestAnimationFrame"]; window.cancelAnimationFrame = window[c[a] + "CancelAnimationFrame"] || window[c[a] + "CancelRequestAnimationFrame"] } if (!window.requestAnimationFrame) { window.requestAnimationFrame = function (h, e) { var d = new Date().getTime(); var f = Math.max(0, 16 - (d - b)); var g = window.setTimeout(function () { h(d + f) }, f); b = d + f; return g } } if (!window.cancelAnimationFrame) { window.cancelAnimationFrame = function (d) { clearTimeout(d) } } }());

    /*
    
     * Point class
    
     */

    var Point = (function () {

      function Point(x, y) {

        this.x = (typeof x !== 'undefined') ? x : 0;

        this.y = (typeof y !== 'undefined') ? y : 0;

      }

      Point.prototype.clone = function () {

        return new Point(this.x, this.y);

      };

      Point.prototype.length = function (length) {

        if (typeof length == 'undefined')

          return Math.sqrt(this.x * this.x + this.y * this.y);

        this.normalize();

        this.x *= length;

        this.y *= length;

        return this;

      };

      Point.prototype.normalize = function () {

        var length = this.length();

        this.x /= length;

        this.y /= length;

        return this;

      };

      return Point;

    })();

    /*
    
     * Particle class
    
     */

    var Particle = (function () {

      function Particle() {

        this.position = new Point();

        this.velocity = new Point();

        this.acceleration = new Point();

        this.age = 0;

      }

      Particle.prototype.initialize = function (x, y, dx, dy) {

        this.position.x = x;

        this.position.y = y;

        this.velocity.x = dx;

        this.velocity.y = dy;

        this.acceleration.x = dx * settings.particles.effect;

        this.acceleration.y = dy * settings.particles.effect;

        this.age = 0;

      };

      Particle.prototype.update = function (deltaTime) {

        this.position.x += this.velocity.x * deltaTime;

        this.position.y += this.velocity.y * deltaTime;

        this.velocity.x += this.acceleration.x * deltaTime;

        this.velocity.y += this.acceleration.y * deltaTime;

        this.age += deltaTime;

      };

      Particle.prototype.draw = function (context, image) {

        function ease(t) {

          return (--t) * t * t + 1;

        }

        var size = image.width * ease(this.age / settings.particles.duration);

        context.globalAlpha = 1 - this.age / settings.particles.duration;

        context.drawImage(image, this.position.x - size / 2, this.position.y - size / 2, size, size);

      };

      return Particle;

    })();

    /*
    
     * ParticlePool class
    
     */

    var ParticlePool = (function () {

      var particles,

        firstActive = 0,

        firstFree = 0,

        duration = settings.particles.duration;



      function ParticlePool(length) {

        // create and populate particle pool

        particles = new Array(length);

        for (var i = 0; i < particles.length; i++)

          particles[i] = new Particle();

      }

      ParticlePool.prototype.add = function (x, y, dx, dy) {

        particles[firstFree].initialize(x, y, dx, dy);



        // handle circular queue

        firstFree++;

        if (firstFree == particles.length) firstFree = 0;

        if (firstActive == firstFree) firstActive++;

        if (firstActive == particles.length) firstActive = 0;

      };

      ParticlePool.prototype.update = function (deltaTime) {

        var i;



        // update active particles

        if (firstActive < firstFree) {

          for (i = firstActive; i < firstFree; i++)

            particles[i].update(deltaTime);

        }

        if (firstFree < firstActive) {

          for (i = firstActive; i < particles.length; i++)

            particles[i].update(deltaTime);

          for (i = 0; i < firstFree; i++)

            particles[i].update(deltaTime);

        }



        // remove inactive particles

        while (particles[firstActive].age >= duration && firstActive != firstFree) {

          firstActive++;

          if (firstActive == particles.length) firstActive = 0;

        }





      };

      ParticlePool.prototype.draw = function (context, image) {

        // draw active particles

        if (firstActive < firstFree) {

          for (i = firstActive; i < firstFree; i++)

            particles[i].draw(context, image);

        }

        if (firstFree < firstActive) {

          for (i = firstActive; i < particles.length; i++)

            particles[i].draw(context, image);

          for (i = 0; i < firstFree; i++)

            particles[i].draw(context, image);

        }

      };

      return ParticlePool;

    })();

    /*
    
     * Putting it all together
    
     */

    (function (canvas) {

      var context = canvas.getContext('2d'),

        particles = new ParticlePool(settings.particles.length),

        particleRate = settings.particles.length / settings.particles.duration, // particles/sec

        time;



      // get point on heart with -PI <= t <= PI

      function pointOnHeart(t) {

        return new Point(

          160 * Math.pow(Math.sin(t), 3),

          130 * Math.cos(t) - 50 * Math.cos(2 * t) - 20 * Math.cos(3 * t) - 10 * Math.cos(4 * t) + 25

        );

      }



      // creating the particle image using a dummy canvas

      var image = (function () {

        var canvas = document.createElement('canvas'),

          context = canvas.getContext('2d');

        canvas.width = settings.particles.size;

        canvas.height = settings.particles.size;

        // helper function to create the path

        function to(t) {

          var point = pointOnHeart(t);

          point.x = settings.particles.size / 2 + point.x * settings.particles.size / 350;

          point.y = settings.particles.size / 2 - point.y * settings.particles.size / 350;

          return point;

        }

        // create the path

        context.beginPath();

        var t = -Math.PI;

        var point = to(t);

        context.moveTo(point.x, point.y);

        while (t < Math.PI) {

          t += 0.01; // baby steps!

          point = to(t);

          context.lineTo(point.x, point.y);

        }

        context.closePath();

        // create the fill

        context.fillStyle = '#FF5CA4';

        context.fill();

        // create the image

        var image = new Image();

        image.src = canvas.toDataURL();

        return image;

      })();



      // render that thing!

      function render() {

        // next animation frame

        requestAnimationFrame(render);



        // update time

        var newTime = new Date().getTime() / 1000,

          deltaTime = newTime - (time || newTime);

        time = newTime;



        // clear canvas

        context.clearRect(0, 0, canvas.width, canvas.height);



        // create new particles

        var amount = particleRate * deltaTime;

        for (var i = 0; i < amount; i++) {

          var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random());

          var dir = pos.clone().length(settings.particles.velocity);

          particles.add(canvas.width / 2 + pos.x, canvas.height / 2 - pos.y, dir.x, -dir.y);

        }



        // update and draw particles

        particles.update(deltaTime);

        particles.draw(context, image);

      }



      // handle (re-)sizing of the canvas

      function onResize() {

        canvas.width = canvas.clientWidth;

        canvas.height = canvas.clientHeight;

      }

      window.onresize = onResize;



      // delay rendering bootstrap

      setTimeout(function () {

        onResize();

        render();

      }, 10);

    })(document.getElementById('pinkboard'));
    (function (canvas) {

      var context = canvas.getContext('2d'),

        particles = new ParticlePool(settings.particles.length),

        particleRate = settings.particles.length / settings.particles.duration, // particles/sec

        time;



      // get point on heart with -PI <= t <= PI

      function pointOnHeart(t) {

        return new Point(

          160 * Math.pow(Math.sin(t), 3),

          130 * Math.cos(t) - 50 * Math.cos(2 * t) - 20 * Math.cos(3 * t) - 10 * Math.cos(4 * t) + 25

        );

      }



      // creating the particle image using a dummy canvas

      var image = (function () {

        var canvas = document.createElement('canvas'),

          context = canvas.getContext('2d');

        canvas.width = settings.particles.size;

        canvas.height = settings.particles.size;

        // helper function to create the path

        function to(t) {

          var point = pointOnHeart(t);

          point.x = settings.particles.size / 2 + point.x * settings.particles.size / 350;

          point.y = settings.particles.size / 2 - point.y * settings.particles.size / 350;

          return point;

        }

        // create the path

        context.beginPath();

        var t = -Math.PI;

        var point = to(t);

        context.moveTo(point.x, point.y);

        while (t < Math.PI) {

          t += 0.01; // baby steps!

          point = to(t);

          context.lineTo(point.x, point.y);

        }

        context.closePath();

        // create the fill

        context.fillStyle = '#FF5CA4';

        context.fill();

        // create the image

        var image = new Image();

        image.src = canvas.toDataURL();

        return image;

      })();



      // render that thing!

      function render() {

        // next animation frame

        requestAnimationFrame(render);



        // update time

        var newTime = new Date().getTime() / 1000,

          deltaTime = newTime - (time || newTime);

        time = newTime;



        // clear canvas

        context.clearRect(0, 0, canvas.width, canvas.height);



        // create new particles

        var amount = particleRate * deltaTime;

        for (var i = 0; i < amount; i++) {

          var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random());

          var dir = pos.clone().length(settings.particles.velocity);

          particles.add(canvas.width / 2 + pos.x, canvas.height / 2 - pos.y, dir.x, -dir.y);

        }



        // update and draw particles

        particles.update(deltaTime);

        particles.draw(context, image);

      }



      // handle (re-)sizing of the canvas

      function onResize() {

        canvas.width = canvas.clientWidth;

        canvas.height = canvas.clientHeight;

      }

      window.onresize = onResize;



      // delay rendering bootstrap

      setTimeout(function () {

        onResize();

        render();

      }, 10);

    })(document.getElementById('pinkboard1'));

  </script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.min.js"
    integrity="sha384-Rx+T1VzGupg4BHQYs2gCW9It+akI2MM/mndMCy36UVfodzcJcF0GGLxZIzObiEfa"
    crossorigin="anonymous"></script>
</body>

</html>
